# InnoDB의 Index Lock
 
InnoDB는 데이터 접근 시 효율성을 위해 인덱스를 사용하며, 이를 기반으로 잠금을 설정한다. <br/>
InnoDB가 인덱스를 사용할 때 적용되는 잠금 메커니즘을 알아보자.

<br/>

## (1) 레코드 기반 잠금
: 특정 행(레코드)를 잠그며, 주요 키 또는 보조 키를 기반으로 데이터에 접근할 때 해당 행만 잠긴다.
- InnoDB는 **클러스터링 인덱스(Primary Key)** 를 사용해 데이터에 접근한다. <br/>
- 특정 레코드(행) 또는 레코드 범위를 잠그기 위해 인덱스를 사용한다.

<br/>

## (2) 갭 잠금(Gap Lock)
: 인덱스에서 특정 범위 내 존재하지 않는 값(갭)을 잠그며, 근처 범위에 새로은 레코드가 삽입되지 않도록 보호한다.
> `(5, 10)` 범위에 갭 락이 걸리면, `id = 6`, `id = 8` 과 같은 값은 삽입될 수 없다.
- 인덱스 범위를 지정할 때 존재하지 않는 레코드(갭, Gap)도 잠근다. <br/>
- 주로 `REPEATABLE READ` 격리 수준에서 활성화된다. <br/>
- 팬텀 문제(다른 트랜잭션에서 새 레코드 삽입 시 데이터 불일치)가 발생하지 않도록 방지한다.

<br/>

## (3) 넥스트 키 잠금 (Next-Key Lock)
: 레코드 잠금 + 갭 잠금의 결합 형태.
> `id = 5` 를 조회하면, `id = 5` 뿐만 아니라 (4, 5), (5, 6) 갭도 잠금이 걸린다.

- 인덱스에서 특정 레코드와 그 바로 옆의 갭을 잠근다.
- 트랜잭션 격리 수준이 `REPEATABLE READ` 일 때 기본적으로 활성화된다.

<br/>

바이너리 로그 포맷과 락 동작
---
> MySQL 의 바이너리 로그 포맷은 트랜잭션의 변경 사항을 기록하는 방식으로, 다음은 주요 설정들이다.

1. `STATEMENT`
   - SQL 문장을 그대로 기록한다.
   - 조건부 갱신, 예를 들어 `UPDATE ... WHERE` 과 같은 갱신은 검색 범위에 갭 락이나 넥스트 키 락을 적용해야 하므로 잠금이 많이 발생한다.
  
2. `ROW`
   - 변경된 행(Row) 데이터만 기록한다.
   - _정확히 변경된 행에만 초점을 맞추기 때문에 갭 락과 넥스트 키 락이 최소화된다._
