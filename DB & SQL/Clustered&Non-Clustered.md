# Clustered Index & Non-Clustered Index

Clustered 의 사전 정의 : (비슷한 사물이나 사람들의 집단에 대해) 어떤 것을 둘러싸서 집단을 형성하거나, 어떤 것을 그렇게 만들다.

> 데이터베이스 인덱스는 데이터 검색 성능을 향상시키기 위해 사용되며, 크게 클러스터드 인덱스와 논클러스터드 인덱스로 나뉜다.
> 이 두 가지 인덱스의 차이는 데이터가 물리적으로 저장되는 방식과 데이터 접근 성능에 영향을 미친다.

<br/>

# 1. 클러스터드 인덱스 (Clustered Index)
> 클러스터드 인덱스는 테이블의 데이터 자체가 인덱스로 구성되는 구조다. <br/>
> 일반적으로 **기본 키(Primary Key)** 로 설정된 컬럼에 대해 자동으로 생성되고 __한 테이블에 하나의 클러스터드 인덱스만 존재할 수 있다.__

- ex) 도서관에서 '개발' 이라는 카테고리 영역을 정해놓고 그 영역들에 '개발' 서적들의 위치를 모아 놓은 것.

<br/>

특징
---

- **물리적 데이터 정렬** : 테이블의 데이터가 인덱스 순서에 따라 물리적으로 정렬되어 저장된다.
- **실제 데이터 페이지와 연결** : 인덱스가 곧 데이터이므로, 인덱스 자체가 데이터 페이지를 가리키는 것이 아니라 데이터 페이지와 동일하다.
- **빠른 데이터 검색** : 인덱스와 데이터가 동일한 구조이기 때문에 인덱스를 탐색하면 곧바로 데이터 페이지에 접근할 수 있어 빠른 검색이 가능하다.

장점
---

- 데이터 검색 성능이 뛰어나고 특히 범위 조회(BETWEEN, >, < 등)에 유리하다.
- _물리적으로 정렬된 상태_ 이므로, `ORDER BY`나 `GROUP BY` 절을 사용할 때 성능이 향상된다.

단점
---

- 삽입/삭제/갱신 작업의 성능이 떨어질 수 있다. 데이터가 물리적으로 정렬되기 때문에, 새로운 데이터를 삽입하거나 기존 데이터를 삭제할 때 페이지 분할(Page Splitting) 또는 데이터 재정렬이 발생할 수 있다.
- 클러스터드 인덱스를 설정하면 데이터의 물리적 순서가 변경되므로, 대량의 데이터를 추가하거나 갱신할 때는 주의가 필요하다.

예시:

```sql
-- 기존 테이블에 클러스터드 인덱스 생성
CREATE CLUSTERED INDEX idx_clustered_id ON employees(id);

-- 테이블 생성 시 클러스터드 인덱스를 기본 키로 설정
CREATE TABLE employees (
    id INT PRIMARY KEY, -- 클러스터드 인덱스가 자동으로 생성됨
    name VARCHAR(100),
    department VARCHAR(100)
);
```

<br/>

# 2. 논클러스터드 인덱스 (Non-Clustered Index)
> 논클러스터드 인덱스는 실제 데이터와 별개로 인덱스 테이블을 유지하며, 인덱스 테이블은 ___데이터 페이지의 주소(포인터)___ 를 저장하고 있는 구조다.
> __하나의 테이블에 여러 개의 논클러스터드 인덱스를 생성할 수 있다.__

- ex) 서적들을 '개발' 카테고리 영역에 모아두는 것이 아니라 해당 서적들의 물리적인 위치는 이동시키지 않고 각 서적들의 위치 정보들을 별도로 저장하는 것.

<br/>

특징
---

- __별도의 인덱스 구조__ : 데이터 페이지와 별도로 인덱스 페이지가 존재하며, 인덱스가 데이터를 가리키는 포인터를 가지고 있다.
- __실제 데이터와 인덱스 분리__ : 논클러스터드 인덱스는 테이블의 데이터가 물리적으로 정렬되지 않기 때문에, 인덱스 탐색 후 실제 데이터를 검색하기 위해 한 번 더 접근해야 한다.
B-Tree 구조를 사용하여 인덱스 페이지와 데이터 페이지 간의 연결을 관리한다.

장점
---
- 다양한 조회 성능의 향상을 기대할 수 있다. __특정 컬럼에 대해 여러 개의 논클러스터드 인덱스를 생성할 수 있으므로,__ 다양한 조회 패턴에서 성능이 향상될 수 있다.
- 클러스터드 인덱스와 달리 데이터의 __물리적 순서에 영향을 주지 않으므로 삽입/삭제/갱신 작업의 영향이 적다.__

단점
---
- 추가적인 스토리지 공간이 필요하다. 각 논클러스터드 인덱스는 데이터와 별개로 저장되므로 스토리지 비용이 증가할 수 있다.
- 포인터를 사용한 데이터 접근 때문에, 범위 검색이나 복잡한 쿼리에서는 클러스터드 인덱스보다 검색 성능이 낮을 수 있다.

예시:
```sql
-- 논클러스터드 인덱스 생성
CREATE INDEX idx_employee_name ON employees(name);

-- 여러 컬럼에 대해 논클러스터드 인덱스 생성
CREATE INDEX idx_employee_dept_name ON employees(department, name);
```
